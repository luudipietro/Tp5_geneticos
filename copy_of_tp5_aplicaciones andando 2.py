# -*- coding: utf-8 -*-
"""Copy of TP5 - Aplicaciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HyIfZVUn9TQhCuBxOV54IO9lLjaitIc2

Algoritmos Genéticos y Optimización Heurística - UTN-FRT
# **Trabajo Práctico N°5**
##**Tema**: Aplicaciones de AG##

Objetivo: Aplicar heurísticas a problemas reales.

Integrantes
Carlino Luciano
Di Pietro Luciano

## Ejercicio 1

Utilice el AG Simple para resolver el problema del viajante o TSP (Travelling Salesman Problem):
* Se tienen **N** ciudades por las cuales el viajante debe pasar.
* El viajante pasa sólo una vez por cada ciudad.
* Inicia en una ciudad, hace su recorrido y vuelve a la ciudad de inicio.
* El objetivo es encontrar el camino más corto que el viajante debe recorrer para pasar por todas las ciudades.

El caso particular que usted debe resolver consiste de 14 ciudades, cuyas coordenadas son las siguientes (tomar la primera como punto de partida):
"""

coordenadas = [
  [-7.5984,-1.9725],
  [-6.7323, 1.8807],
  [-2.7165, 4.2661],
  [-1.2992, 5.5505],
  [-6.1024, 8.9450],
  [-2.4803, 8.9450],
  [ 4.2913, 7.0183],
  [ 7.0472, 6.1009],
  [ 8.1496, 8.4862],
  [ 8.9370, 0.5963],
  [ 2.6378, 0.6881],
  [ 6.1811,-4.6330],
  [ 1.7717,-7.0183],
  [-5.1575,-8.4862]
]

# x = [c[0] for c in coordenadas]
# y = [c[1] for c in coordenadas]
# import matplotlib.pyplot as plt
# plt.plot(x, y, 'xr', label='Ciudades');
# plt.plot(x[0], y[0], 'or', label='Inicio');
# for i in range(len(coordenadas)):
#     plt.text(x[i], y[i], i)
# plt.legend()
# plt.grid()
# plt.xlim([-9,12])
# print("Ciudades para el problema de TSP")
# plt.show()

"""El algoritmo requiere conocer las distancias entre las ciudades para poder calcular la distancia total recorrida. Para ello se propone la siguiente funcion para calcular la distancia entre una ciudad *i* y *j*:"""

import math
def distancia(coord_i, coord_j):
  #distancia Euclidea
  return math.sqrt((coord_i[0]-coord_j[0])**2 + (coord_i[1]-coord_j[1])**2)

# #ejemplo
# ciudad_i = 1
# ciudad_j = 5
# d = distancia(coordenadas[ciudad_i], coordenadas[ciudad_j])
# print("Distancia entre ciudad %d y %d; %f"%(ciudad_i, ciudad_j, d))

# Operadores adicionales

def mut_swap(p, Bounds, n=1):
    m = p.copy()
    #genero permutacion al azar para elegir coordenadas distintas al azar
    r = list(range(len(m)-1))  #r = list(range(len(m)))
    random.shuffle(r)
    #indices de coordenadas origen
    o = r[:n]
    #indices de coordenadas destino
    d = r[n:2*n]
    #asigno nuevos valores a las coordenadas del mutado
    for i in range(len(o)):
        m[o[i]] = p[d[i]]
        m[d[i]] = p[o[i]]
    return m

def mut_adjoin_swap(p, Bounds, n=1):
    #copio el padre
    m = p.copy()
    #genero permutacion al azar para elegir coordenadas distintas al azar
    r = list(range(len(m)-1))  #r = list(range(len(m)))
    random.shuffle(r)
    #indices de coordenadas origen
    o = r[:n]
    #indices de coordenadas destino
    d = [(x + 1) for x in o]  #d = [(x + 1) % len(m) for x in o]
    #asigno nuevos valores a las coordenadas del mutado
    for i in range(len(o)):
        m[o[i]] = p[d[i]]
        m[d[i]] = p[o[i]]
    return m

def mut_inversion(p, Bounds):
    #copio el padre
    m = p.copy()
    #genero permutacion al azar para elegir dos puntos de corte distintos
    r = list(range(len(m)))
    random.shuffle(r)
    #indices de coordenadas origen
    #o = [x % len(m) for x in range(r[0], r[1] + (len(m) if r[1] < r[0] else 0))]
    o = [x for x in range(min(r[:2]), max(r[:2]))]
    #asigno nuevos valores a las coordenadas del mutado
    for i in range(len(o)):
        m[o[i]] = p[o[-i-1]]
    return m

def mut_shift_left(p, Bounds):
    #copio el padre
    m = p.copy()
    #genero permutacion al azar para elegir dos puntos de corte distintos
    r = list(range(len(m)))
    random.shuffle(r)
    #indices de coordenadas origen
    #o = [x % len(m) for x in range(r[0], r[1] + (len(m) if r[1] < r[0] else 0))]
    o = [x for x in range(min(r[:2]), max(r[:2]))]
    #indices de coordenadas destino
    d = [x + 1 for x in o]  #d = [(x + 1) % len(m) for x in o]
    d[-1] = o[0]
    #asigno nuevos valores a las coordenadas del mutado
    for i in range(len(o)):
        m[o[i]] = p[d[i]]
    return m

def mut_shift_right(p, Bounds):
    #copio el padre
    m = p.copy()
    #genero permutacion al azar para elegir dos puntos de corte distintos
    r = list(range(len(m)))
    random.shuffle(r)
    #indices de coordenadas origen
    #o = [x % len(m) for x in range(r[0], r[1] + (len(m) if r[1] < r[0] else 0))]
    o = [x for x in range(min(r[:2]), max(r[:2]))]
    #indices de coordenadas destino
    d = [x - 1 for x in o]  #d = [(x - 1) % len(m) for x in o]
    d[0] = o[-1]
    #asigno nuevos valores a las coordenadas del mutado
    for i in range(len(o)):
        m[o[i]] = p[d[i]]
    return m

def xov_partial_map(p1, p2):
    c1 = p1.copy()
    c2 = p2.copy()
    n = len(c1);
    #genero permutacion al azar para elegir dos puntos de corte distintos
    r = list(range(n))
    random.shuffle(r)
    #creo la mascara
    mask = [0]*n
    for i in range(min(r[:2]), max(r[:2])):
        mask[i] = 1
    #tacho valores que estan en p1 y p2
    m1 = [1]*n
    m2 = [1]*n
    for i in range(n):
        if not mask[i]:
            for j in range(n):
                if p1[i] == p2[j]:
                    m1[j] = 0
                if p2[i] == p1[j]:
                    m2[j] = 0
    j = k = 0
    #pongo calores no tachados en c1 y c2
    for i in range(n):
        if mask[i]:
            while m1[j] == 0:
                j += 1
            while m2[k] == 0:
                k += 1
            c1[i] = p2[j]
            c2[i] = p1[k]
            j += 1
            k += 1
    return c1, c2

def xov_order_based(p1, p2):
    c1 = p1.copy()
    c2 = p2.copy()
    n = len(c1)
    #crear mascara al azar
    mask = [random.randint(0,1) for i in range(n)]
    #tacho valores que estan en p1 y p2
    m1 = [1]*n
    m2 = [1]*n
    for i in range(n):
        if not mask[i]:
            for j in range(n):
                if p1[i] == p2[j]:
                    m1[j] = 0
                if p2[i] == p1[j]:
                    m2[j] = 0
    j = k = 0
    #pongo calores no tachados en c1 y c2
    for i in range(n):
        if mask[i]:
            while m1[j] == 0:
                j += 1
            while m2[k] == 0:
                k += 1
            c1[i] = p2[j]
            c2[i] = p1[k]
            j += 1
            k += 1
    return c1, c2


def sel_ruleta(F, cant_selectos, eps):
    """ Operador de selección por torneos.
    Parametros:
    F: list. Lista de valores de fitness de cada individuo de la población.
    cant_selectos: int. Cantidad de individuos a seleccionar.
    eps: int. valor para normalizar el fitness.
    S: list. Lista con las posiciones de los individuos seleccionados.
    """

    S = []
    min_valor = min(F)
    lista_ajustada = [(x - min_valor + eps) for x in F] #hacemos que sean todos positivos y mayores a cero
    suma = sum(lista_ajustada)
    pesos = [(x / suma) for x in lista_ajustada]
    puntos_de_corte = [(sum(pesos[:i+1])) for i in range(len(pesos))]
    tiros = [random.random() for i in range(cant_selectos)]
    for tiro in tiros:
        for i in range(len(puntos_de_corte)):
            if tiro < puntos_de_corte[i]:
                S.append(i)
                break

    return S


def sel_sus(F, cant_selectos, eps):
    """ Operador de seleccion stochastic universal sampling (SUS).
    Parametros:
    F: list. Lista de valores de fitness de cada individuo de la población.
    cant_selectos: int. Cantidad de individuos a seleccionar.
    eps: int. valor para normalizar el fitness.
    S: list. Lista con las posiciones de los individuos seleccionados.
    """
    random_num = random.uniform(0, (1 / len(F)))
    S = [int(random_num + i * (1 / len(F))) for i in range(cant_selectos)]
    return S

"""Se pide:
1. Determinar una codificación adecuada (forma de representar las soluciones  para el problema).
2. Definir las restricciones para los valores en la solución (determinar la matriz de *Bounds*).
3. En base a la codificación elegida, definir una función *Fitness* que permita encontrar buenas soluciones en base al objetivo del problema.
4. Determinar una arquitectura de algoritmos genéticos adecuada para resolver el problema:
  * Definir que tipo de algoritmo genético utilizar.
  * Elegir los operadores genéticos a utilizar.
5. Ajustar los parámetros adecuadamentes usando los criterios utilizados en los prácticos anteriores. La cantidad de generaciones y tamaño de la población pueden variar al tomar diferentes cantidades de ciudades.
"""

import matplotlib.pyplot as plt
import random
import numpy as np
import itertools
import sympy as sp
from shapely.geometry import LineString, Point

def geneticoSimple(Pop, cant_generac, Bounds, Enteras, sel, xover, mut, \
                   cant_cruzados, cant_mutados, cant_elite, param_sel, f, coordenadas, \
                   fitness_weight, intersections_weight, measure_intersections, callback=None):
    """
    Algoritmo Genetico Simple
    Parametros:
    - Pop: list. poblacion inicial (lista de listas).
    - cant_generac: int. Cantidad de iteraciones del algoritmo. Usamos cantidad de generaciones sin mejora
    - Bounds: list: Matriz que indica los valores max y min de cada variable.
    - Enteras: list. Vector booleano que indica si las coordenadas son enteras.
    - cant_cruzados: int. Cantidad de individuos que seran cruzados.
    - cant_mutados: int. Cantidad de soluciones a las cuales se le aplicara
      mutacion.
    - cant_elite: int. Numero de mejores soluciones que pasan a la siguiente
      generacion sin cambio alguno.
    - param_sel: float. Parametro usado en la seleccion, por ejemplo el peso que
      se le asigna a la solucion menos probable en el calculo de la probabilidad
      para ruleta. En caso de usar torneo, este es el tamano del torneo.
    - f: function. Funcion de evaluacion. Debe recibir como parametro un vector
      solucion y devolver un numero real.
    - intersections_weight: Un peso en distancia para las intersecciones en el recorrido
    - measure_intersections: Si tengo en cuenta la penalidad por usar intersecciones
    - callback: function. Funcion que se ejecuta una vez en cada iteracion (para
      mostrar resultados parciales). Usar None para deshabilitarla.
    Salida
    - soluc: list. Vector solucion que obtuvo fitness mas alto.
    - solF: float. Valor de evaluacion de la mejor solucion.
    - Pop: list. Poblacion final.
    - Fit: list. Fitness de cada individuo de la poblacion final.
    - traceBest: list. Vector con los mejores valores de fitness obtenidos en
      cada generacion. Se puede utilizar para determinar si el algoritmo
      llego a crowding.
    - traceAvg: list. Vector con los valores promedio de fitness
      obtenidos en cada generacion.
    """
    #inicializacion
    sol = []
    solF = None
    cant_soluc = len(Pop)
    Fit = [None] * cant_soluc
    traceBest = []
    traceAvg = []
    bestSols = []
    mejor = 0
    cant_intentos_malos = 0
    #mejor conserva el valor de la mejor solucion
    #cant_intentos malos va acumulando y sera mi condicion de parada.

    #verifico los parametros de entrada
    if cant_soluc < 2:
        print('La Poblacion debe tener al menos dos individuos.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols
    cant_variables = len(Pop[0])
    if len(Bounds) != cant_variables or len(Bounds[0]) != 2:
        print('El tamano de la matriz Bounds es incorrecto.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols
    if len(Enteras) != cant_variables:
        print('El tamano del vector Enteras es incorrecto.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols
    if cant_cruzados > cant_soluc:
        print('La cantidad de cruzados debe ser menor que el tamano de la poblacion.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols
    if cant_mutados > cant_soluc:
        print('La cantidad de mutados debe ser menor que el tamano de la poblacion.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols
    if cant_elite >= cant_soluc:
        print('El tamano de la elite debe ser menor que el tamano de la poblacion.')
        return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols

    #inicializo variables para reducir tiempo de calculo
    cb_param = None
    p = [i for i in range(cant_soluc)]

    #realizo las evaluaciones de la poblacion inicial.
    for k in range(cant_soluc):
        #Pop[k] = [xi if not Enteras[i] else int(xi+0.5) for i, xi in enumerate(Pop[k])]
        Fit[k] = f(Pop[k], coordenadas, fitness_weight,intersections_weight, measure_intersections)
    #if callback != None:
     #   cb_param = callback(Pop, Fit, Bounds, 0, cant_generac, cb_param)
    #obtengo el orden de los individuos
    p_orden = sorted(range(len(Fit)), key=lambda k: Fit[k], reverse=True)
    mejor = Fit[p_orden[0]]


    while(True):
        # print(f'Generacion: {gen}')
        #selecciono la elite de la generacion actual (una copia)
        Elite = [[xi for xi in Pop[p_orden[k]]] for k in range(cant_elite)]
        Elite_Fit = [Fit[p_orden[k]] for k in range(cant_elite)]

        #seleccion
        p_sel = sel(Fit, cant_soluc, param_sel)
        random.shuffle(p)
        Pop = [Pop[p_sel[k]] for k in p]
        Fit = [Fit[p_sel[k]] for k in p]

        #cruzamiento
        random.shuffle(p)
        for k in range(0, cant_cruzados-1, 2):
            C1, C2 = xover(Pop[p[k]], Pop[p[k+1]])
            Pop[p[k]] = [xi for xi in C1]
            Pop[p[k+1]] = [xi for xi in C2]
            Fit[p[k]] = None
            Fit[p[k+1]] = None

        #mutacion
        random.shuffle(p)
        for k in range(cant_mutados):
            C = mut(Pop[p[k]], Bounds)
            Pop[p[k]] = [xi for xi in C]
            Fit[p[k]] = None

        #inserto la elite en la nueva poblacion en lugares al azar
        random.shuffle(p)
        for k in range(cant_elite):
            Pop[p[k]] = Elite[k]
            Fit[p[k]] = Elite_Fit[k]

        #realizo las evaluaciones de la nueva generacion
        for k in range(cant_soluc):
            if Fit[k] == None:
                Pop[k] = [xi if not Enteras[i] else int(xi+0.5) for i, xi in enumerate(Pop[k])]
                Fit[k] = f(Pop[k], coordenadas, fitness_weight,intersections_weight, measure_intersections)

        #obtengo el orden de los individuos
        p_orden = sorted(range(len(Fit)), key=lambda k: Fit[k], reverse=True)


        #datos estadisticos
        traceBest.append(Fit[p_orden[0]])
        traceAvg.append(sum(Fit) / len(Fit))
        bestSols.append([xi for xi in Pop[p_orden[0]]])

        if mejor >= Fit[p_orden[0]]:
          cant_intentos_malos += 1
        else:
          cant_intentos_malos = 0
          mejor = Fit[p_orden[0]]

        if cant_intentos_malos >= cant_generac:
          solF = Fit[p_orden[0]]
          sol = Pop[p_orden[0]]
          return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols


        #funcion para graficar, mostrar, etc.
        if callback != None:
            cb_param = callback(Pop, Fit, Bounds, gen, cant_generac, cb_param)

    #busco la mejor solucion obtenida
    # solF = Fit[p_orden[0]]
    # sol = Pop[p_orden[0]]
    # #graficar_generacion(Pop)

    # return sol, solF, Pop, Fit, traceBest, traceAvg, bestSols

def graficarEvolucionFitness(best, mean):
    """Método para graficar la evolucion del fitness con las iteraciones.
    Parametros
    best, mean : list. Lista con los valores de evaluación de la mejor y peor solución.
    """
    fig = plt.figure()
    ax = plt.axes()
    x = range(len(best))
    plt.plot(x, best, label='Mejor solución')
    plt.plot(x, mean, label='Promedio poblacion')
    plt.title('Valores de Evaluación')
    plt.xlabel('Iteración')
    plt.ylabel('Fitness')
    plt.grid()
    plt.legend()
    plt.show()

def create_array_base(num_ciudades, punto_inicial):
    array_base = list(range(0, num_ciudades))
    array_base.remove(punto_inicial)
    random.shuffle(array_base)
    return array_base

def init_pop_tsp(num_ciudades, punto_inicial, cantidad_individuos, Bounds):
    return [create_array_base(num_ciudades, punto_inicial) for i in range(cantidad_individuos)]

import math
def distancia(coord_i, coord_j):
  #distancia Euclidea
  return math.sqrt((coord_i[0]-coord_j[0])**2 + (coord_i[1]-coord_j[1])**2)


def funcion_evaluacion(individuo, coordenadas):
    dist_total = sum(distancia(coordenadas[individuo[i]], coordenadas[individuo[i+1]]) for i in range(len(individuo) - 1))


    return dist_total


def penalizacion_por_interseccion(individuo, measure_intersections):
    if measure_intersections:
         intersections = count_intersections(get_routes_info(individuo, coordenadas))
         #print(len(intersections))

    return len(intersections) if len(intersections) > 0 else 0

def g_solucion(individuo, coordenadas, fitness_weight = 1, intersections_weight= 30, measure_intersections=False):
  individuoCompleto = individuo.copy()
  individuoCompleto.append(0)
  individuoCompleto.insert(0,0)
  penalizacion = intersections_weight * penalizacion_por_interseccion(individuoCompleto, measure_intersections)
  evaluacion = fitness_weight * funcion_evaluacion(individuoCompleto, coordenadas)

  return (1/((evaluacion + penalizacion) ** 2)) * 1000000000


def graficar_recorrido(ciudades_list, intersections):
    x = [coordenadas[i][0] for i in ciudades_list]
    y = [coordenadas[i][1] for i in ciudades_list]
    intersections_x = [i[0] for i in intersections]
    intersections_y = [i[1] for i in intersections]
    plt.plot(x, y, label='Recorrido');
    plt.plot(x, y, 'xr', label='Ciudades');
    plt.plot(intersections_x, intersections_y, 'xk', label='Intersecciones');
    plt.plot(x[0], y[0], 'or', label='Inicio');
    for i in range(len(coordenadas)):
        plt.text(coordenadas[i][0], coordenadas[i][1], i)
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    plt.grid()
    plt.xlim([-9,12])
    print("Ciudades para el problema de TSP")
    plt.show()

def get_routes_info(individuo, coordenadas):

    r = []
    for i in range(len(individuo) - 1):
        try:
            slope = (coordenadas[individuo[i+1]][1] - coordenadas[individuo[i]][1]) / (coordenadas[individuo[i+1]][0] - coordenadas[individuo[i]][0])
        except ZeroDivisionError:
            slope = 0
        r.append([[coordenadas[individuo[i]][0], coordenadas[individuo[i]][1]],
         [coordenadas[individuo[i+1]][0], coordenadas[individuo[i+1]][1]], slope, i, i+1])
    return r

def count_intersections(segments):
    intersection_points = []

    for seg1, seg2 in itertools.combinations(segments, 2):
        point = find_segment_intersection_v2(seg1, seg2)

        if point is not None:
            # print(f'Hay una interseccion entre el segmento {seg1[3]}-{seg1[4]} y el segmento {seg2[3]}-{seg2[4]}')
            # print(f'En el punto: X-{point[0]} - Y-{point[1]}')
            intersection_points.append([point[0], point[1]])

    return intersection_points

def find_segment_intersection(rec1, rec2):
    (x1, y1), (x2, y2), slope1, _, _ = rec1
    (x3, y3), (x4, y4), slope2, _, _ = rec2

    x, y = sp.symbols('x y')

    rs1 = slope1 * x1 - y1
    rs2 = slope2 * x3 - y3

    eq1 = sp.Eq(slope1*x - 1*y, rs1)

    eq2 = sp.Eq(slope2*x - 1*y, rs2)

    solucion = sp.solve((eq1, eq2), (x, y))

    if min(x1, x2) < round(solucion[x], 4) < max(x1, x2) and min(x3, x4) < round(solucion[x], 4) < max(x3, x4):
        if min(y1, y2) < round(solucion[y], 4) < max(y1, y2) and min(y3, y4) < round(solucion[y], 4) < max(y3, y4):
            if min(x1, x2) != int(solucion[x] * 10000) / 10000 and max(x1, x2) != int(solucion[x] * 10000) / 10000:
                if min(y1, y2) != int(solucion[y] * 10000) / 10000 and max(y1, y2) != int(solucion[y] * 10000) / 10000:
                    # print(f'Interseccion: {solucion}')

                    # print(f'Limites en y: {min(y1, y2)} - {max(y1, y2) }')
                    # print(f'Limites en x: {min(x1, x2)} - {max(x1, x2)}')

                    return [solucion[x], solucion[y]]
                else:
                    return None

def find_segment_intersection_v2(rec1, rec2):
    (x1, y1), (x2, y2), slope1, _, _ = rec1
    (x3, y3), (x4, y4), slope2, _, _ = rec2

    l1 = LineString([(x1, y1), (x2, y2)])
    l2 = LineString([(x3, y3), (x4, y4)])

    intersection = l1.intersection(l2)

    if isinstance(intersection, Point):
        if min(x1, x2) != int(intersection.x * 10000) / 10000 and max(x1, x2) != int(intersection.x * 10000) / 10000:
                if min(y1, y2) != int(intersection.y * 10000) / 10000 and max(y1, y2) != int(intersection.y * 10000) / 10000:
                    # print(f'X: {intersection.x}')
                    # print(f'Y: {intersection.y}')
                    return [intersection.x, intersection.y]
                else:
                    return None

coordenadas = [
  [-7.5984,-1.9725],
  [-6.7323, 1.8807],
  [-2.7165, 4.2661],
  [-1.2992, 5.5505],
  [-6.1024, 8.9450],
  [-2.4803, 8.9450],
  [ 4.2913, 7.0183],
  [ 7.0472, 6.1009],
  [ 8.1496, 8.4862],
  [ 8.9370, 0.5963],
  [ 2.6378, 0.6881],
  [ 6.1811,-4.6330],
  [ 1.7717,-7.0183],
  [-5.1575,-8.4862]
]
# coordenadas = [
#     [0,0],
#     [1,0],
#     [1,2],
#     [3,2],
#     [3,5],
# ]



Bounds = [[1, len(coordenadas) - 1] for i in range(len(coordenadas)-1)]  #ciudades del 2 al 14

Enteras = [True]* (len(coordenadas)-1)
f = g_solucion
cant_individuos = 40
cant_generac = 50
cant_elite = 1
sel = sel_ruleta
eps = 0.1
xover = xov_order_based
cant_cruzados = round(0.75 * cant_individuos)
mut = mut_swap
cant_mutados = round(0.15 * cant_individuos)
callback = None #usar None para que no grafique y vaya mas rapido

measure_intersections = True
intersections_weight = 500
fitness_weight = 1


mejor_ruta =[1, 4, 5, 2, 3, 6, 8, 7, 9, 10, 11, 12, 13]
#mejor_ruta =[1, 3, 5, 2, 4, 6, 8, 7, 9, 10, 11, 12, 13]
print(f'La menor distancia posible es {math.sqrt(1 / (g_solucion(mejor_ruta, coordenadas, measure_intersections=True)/1000000000))}')

Pop = init_pop_tsp(len(coordenadas), 0, cant_individuos, Bounds)

sol, solF, Pop, Fit, traceBest, traceAvg, bestSols = \
    geneticoSimple(Pop, cant_generac, Bounds, Enteras, sel, xover, mut, \
        cant_cruzados, cant_mutados, cant_elite, eps, f, coordenadas,\
                   fitness_weight, intersections_weight, measure_intersections, callback)

graficarEvolucionFitness(traceBest, traceAvg)
sol.append(0)
sol.insert(0,0)
print("Mejor solución: {0} (Fitness: {1})".format(sol, math.sqrt(1/(solF /1000000000 ))))
print(f'Hay {len(count_intersections(get_routes_info(sol, coordenadas)))} intersecciones')

intersections = count_intersections(get_routes_info(sol, coordenadas))
graficar_recorrido(sol, intersections)

